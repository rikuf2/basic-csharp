{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/part5/part5-3",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Variable types\",\n  \"nav_order\": 3,\n  \"hidden\": false\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"There are two kinds of types in C#: \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"value types\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"reference types\"), \". Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"objects\"), \". \"), mdx(\"p\", null, \"With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable. \"), mdx(\"p\", null, \"With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.\"), mdx(\"p\", null, \"From the programmer's point of view, the data in a value variable is stored as the value of that variable, whereas the value of a reference type varible is a reference to the data. Let's examine these different types with two examples.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int number = 10;\\nConsole.WriteLine(number);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"10\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Name\\n  {\\n    private string name;\\n\\n    public Name(string name)\\n    {\\n      this.name = name;\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"  Name john = new Name(\\\"John\\\");\\n  Console.WriteLine(john);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Exercise001.Name\\n\")), mdx(\"p\", null, \"In the first example we create a simple \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"int\"), \" variable, and the number 10 is stored as its value. When we pass the variable to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Console.WriteLine\"), \" method, the value 10 is printed. In the second example we create a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"reference type\"), \" variable named john. A reference to an object, returned by the constructor of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Name\"), \" class when we call it, is stored as the value of the variable. When this latter variable is printed, the string \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Exercise001.Name\"), \" is what ends up being printed. What is the cause for this?\"), mdx(\"p\", null, \"The method call \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Console.WriteLine\"), \" prints the value of the variable. The value of a simple variable is concrete, whereas the value of a reference type variable is a reference. In the case of a reference type variable, what is printed is the ToString representation of the object. As the default method for any \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object.ToString\"), \" is to print in format \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"namespace.ClassName\"), \", we get \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Exercise001.Name\"), \".\"), mdx(\"p\", null, \"The previous example is the case when the programmer has not changed a variable's default print format. You can change the default print by defining the method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \" in the class of the object in question. The method indicates what string should be printed when an instance of the class is printed. In the example below, we have defined the method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public override string ToString()\"), \" in the class Name: it returns the instance variable name. Now when we print an object that is an instance of Name with the Console.WriteLine command, what is printed is the string returned by the ToString method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Name\\n  {\\n    private string name;\\n\\n    public Name(string name)\\n    {\\n      this.name = name;\\n    }\\n\\n    public override string ToString() {\\n      return this.name;\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Name john = new Name(\\\"John\\\");\\nConsole.WriteLine(john);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"John\\n\")), mdx(\"h2\", {\n    \"id\": \"value-types\"\n  }, \"Value types\"), mdx(\"p\", null, \"A value type is either a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"struct type\"), \" or an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"enumeration type\"), \". C# provides a set of predefined struct types called the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"simple types\"), \". The simple types are identified through reserved words.\"), mdx(\"p\", null, \"A variable of a value type contains an instance of the type. This differs from a variable of a reference type, which contains a reference to an instance of the type. By default, on assignment, passing an argument to a method, or returning a method result, variable values are copied. In the case of value-type variables, the corresponding type instances are copied.\"), mdx(\"p\", null, \"The most interesting (and maybe most important for us) are the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"simple type\"), \". Most of the variables we have handled so far are part of the simple type: int, bool and double are all simple types. It means that they are actually \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"keywords\"), \" that are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"reserved\"), \" to represent certain types from the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"System namespace\"), \". \"), mdx(\"p\", null, \"Because a simple type aliases a struct type, every simple type has members. For example, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"int\"), \" has the members declared in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"System.Int32\"), \" and the members inherited from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"System.Object\"), \", and the following statements are permitted:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int i = int.MaxValue;    // System.Int32.MaxValue constant\\nstring s = i.ToString(); // System.Int32.ToString() instance method\\nstring t = 123.ToString(); // System.Int32.ToString() instance method\\n\")), mdx(\"p\", null, \"In other words, all the basic variables we have been using, are actually just easier way of using methods that are hidden inside the System.\"), mdx(\"p\", null, \"Introducing a value variable reserves a memory location of fixed size from the memory. The size is determined by the type of the variable, and the memory location is where the value of the variable stored at. In the example below we create three variables. Each one has its own memory location, to where the assigned value is copied.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int first = 10;\\nint second = first;\\nint third = second;\\nConsole.WriteLine(first + \\\" \\\" + second + \\\" \\\" + third);\\nsecond = 5;\\nConsole.WriteLine(first + \\\" \\\" + second + \\\" \\\" + third);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"10 10 10\\n10 5 10\\n\")), mdx(\"p\", null, \"The name of the variable tells the memory location where its value is stored. When you assign a value to a value variable with an equality sign, the value on the right side is copied to the memory location indicated by the name of the variable. For example, the statement \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"int first = 10\"), \" reserves a location called first for the variable, and then copies to value 10 into it.\"), mdx(\"p\", null, \"Similarly, the statement \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"int second = first;\"), \" reserves a location called second for the created variable, and then copies the value stored in the location of first into it.\"), mdx(\"p\", null, \"The values of variables are also copied when they are used in method calls. In practice this means that the value of a variable that is passed as a method parameter is not changed in the method that did the passing / called the other method. \"), mdx(\"h2\", {\n    \"id\": \"reference-types\"\n  }, \"Reference types\"), mdx(\"p\", null, \"C#\\u2019s reference type is a class type, an interface type, an array type, or a delegate type. \"), mdx(\"p\", null, \"A reference type value is a reference to an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"instance\"), \" of the type, the latter known as an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"object\"), \". The special value \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \" is compatible with all reference types and indicates the absence of an instance. The programmer is also free to create their own variable types by defining new classes. In practice any object instanced from a class is a reference variable.\"), mdx(\"p\", null, \"Let's re-examine the example at the beginning of the chapter, where we created a variable called john of type Name.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Name john = new Name(\\\"John\\\");\\n\")), mdx(\"p\", null, \"The call consists of the following parts:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When introducing any new variable, we must first define the type of that variable. Below we introduce a variable of type \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Name\"), \". In order for the execution of the program to succeed, there must be a class called \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Name\"), \" available.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Name ...\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In the introduction of a variable its name must be included. You can later use the name of the variable to reference its value. Below, the variable name is defined as luke.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Name john ...\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You can store a value in a variable. You can create an instance object from a class by calling the class constructor, which defines the values that are placed in the instance variables of the object that is created. Below we assume that the class \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Name\"), \" has a constructor that takes a string as parameter.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"... new Name(\\\"John\\\");\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The constructor call returns a value that is a reference to the created object. The equality signs tells the program that the value of the right-side expression is to be copied as the value of the variable on the left side. The reference to the newly-created object, which is returned by the constructor call, is copied as the value of the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"john\"), \" variable.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Name john = new Name(\\\"John\\\");\\n\")), mdx(\"p\", null, \"The greatest difference between value and reference varibales is that the value ones (almost without exception) are unchanging. Conversely, the inner state of reference variables can typically be changed. This phenomenon is explained by the fact that the value of a value variable is directly stored in the variable, whereas the value of a reference variable is a reference to the variable data, i.e. the variable's internal state.\"), mdx(\"p\", null, \"Arithmetic operations, such as addition, subtraction, multiplication, can be used with value variables -- these operations do not change the original values of the variables. Arithmetic expressions create new values, which are stored into variables when needed. Notice that the values of reference variables cannot be changed by these arithmetic expressions.\"), mdx(\"p\", null, \"The value of a reference variable -- i.e. a reference -- points to a location that contains the information that relates to that variable. Let's assume we have the class Person available, and it contains a definition for the instance variable age. If a person object has been instanced of the class, you can find the variable age by following the object's reference. The value of this age variable can be changed, if so needed.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"You can read more about variable types from here\")), \". This rabbit hole of information is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"very deep\"), \" and might take some time to understand.\"), mdx(\"h2\", {\n    \"id\": \"value-or-reference-type-variable-as-a-method-parameter\"\n  }, \"Value or reference type variable as a method parameter\"), mdx(\"p\", null, \"We stated earlier that the value of a value variable is directly stored in that variable, whereas the value of a reference variable contains the reference to an object. We also mentioned that assigning a value with the equality sign copies the value on the right (possibly the value of some variable), and stores it as the value of the left-side variable.\"), mdx(\"p\", null, \"A similar copying occurs when a method is called. Regardless of whether the variable is value or reference type, the value given as a method parameter is copied for the method to use. In the case of value variables, the value of the variable is given to the method; with reference type variables, the method receives a reference.\"), mdx(\"p\", null, \"Let's take a practical look at the phenomenon. Let's assume we have the following \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person\"), \" class available.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Person\\n{\\n  private string name;\\n  public int birthYear { get; set; }\\n\\n  public Person(string name)\\n  {\\n    this.name = name;\\n    this.birthYear = 1970;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.name + \\\" (\\\" + this.birthYear + \\\")\\\";\\n  }\\n}\\n\")), mdx(\"p\", null, \"Let's take a look at the operation of the program step by step.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n\\n  Person first = new Person(\\\"First\\\");\\n\\n  Console.WriteLine(first);\\n  MakeYounger(first);\\n  Console.WriteLine(first);\\n\\n  Person second = first;\\n  MakeYounger(second);\\n\\n  Console.WriteLine(first);\\n}\\n\\npublic static void MakeYounger(Person person)\\n{\\n  person.birthYear++;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"First (1970)\\nFirst (1971)\\nFirst (1972)\\n\")), mdx(\"p\", null, \"The execution of the program begins on the first line of the Main method. On the first row of the Main, a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person type variable\"), \" first is introduced, and the value returned by the constructor of the Person class is copied as its value. The constructor creates an object whose birth year is set as 1970, and whose name is set to be the value received as the paramter. After the execution of this first row the state of the program is the following -- a Person object has been created in the memory, and there is a reference to it from the first variable defined in the Main method.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://github.com/centria/basic-csharp/raw/master/src/images/part5-3-first-1-tm.png\",\n    \"alt\": \"Step one\"\n  })), mdx(\"p\", null, \"On the third row of the Main method we print the value of the variable first. The method call \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Console.WriteLine\"), \" searches for the method ToString from the reference variable that it is given as the parameter. The Person class has the method ToString, so that method is called on the object that is referenced by the first variable. The value of the name variable in that object is \\\"First\\\", and the value of the birth year variable is 1970. What is printed is the string \\\"First (1970)\\\".\"), mdx(\"p\", null, \"On the fourth row the program calls the MakeYounger method, and the variable first is passed as a parameter to it. When the method MakeYounger is called, the value of the variable passed as the parameter is copied for the method MakeYounger to use. The execution of the Main method remains waiting in the call stack. As the variable first is reference type, the reference created earlier is copied for the method's use. At the end of the method execution the situation is the following -- the method increments by one the birth year of the object it receives as a parameter.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://github.com/centria/basic-csharp/raw/master/src/images/part5-3-first-2-tm.png\",\n    \"alt\": \"Step two\"\n  })), mdx(\"p\", null, \"When the execution of the method MakeYounger ends, we return back to the Main method. The information related to the execution of the MakeYounger disappear from the call stack.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://github.com/centria/basic-csharp/raw/master/src/images/part5-3-first-3-tm.png\",\n    \"alt\": \"Step three\"\n  })), mdx(\"p\", null, \"After returning from the method call we again execute the printing of the variable first. The object pointed at by the variable first has been modified in the course of executing the method call \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MakeYounger\"), \": the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"birthYear\"), \" variable of the object was incremented by one. The final value that is printed is \\\"First (1971)\\\".\"), mdx(\"p\", null, \"Then the program introduces a new Person type variable called second. The value of the variable first is copied into the variable second: in other words, the value of the variable second is a reference to the already existing Person object.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://github.com/centria/basic-csharp/raw/master/src/images/part5-3-first-4-tm.png\",\n    \"alt\": \"Step four\"\n  })), mdx(\"p\", null, \"After this the program calls the method MakeYounger, which is given the variable second as the parameter. The value of the given variable is copied as the value of a method variable when the method is called. At the end of the method execution there has been an increment of one in the object referenced by the method variable.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://github.com/centria/basic-csharp/raw/master/src/images/part5-3-first-5-tm.png\",\n    \"alt\": \"Step five\"\n  })), mdx(\"p\", null, \"Finally the method execution ends and the program returns to the Main method. In the Main method the value of the variable first is printed one more time. The final result of the print is \\\"First(1972)\\\".\"), mdx(\"p\", null, \"In the course material the concrete details concerning variables and computer memory are presented simplistically. We introduce memory-related topics on the suitable abstaction level for learning how to program. For instance, from the point of view of the course goals, the following sentence is good enough: \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"statement int number = 5\"), \" reserves a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"location\"), \" for the variable number \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"in the memory\"), \", and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"copies the value 5 into it\"), \".\"), mdx(\"p\", null, \"From the point of view of the computer operation, there are a great deal more occuring during the execution of the statement int number = 5. The execution calls for reserving a 32-bit location from the memory for the value 5, and another 32-bit location for the variable number. The size of the location is determined by the variable type. After this the contents of the memory location that includes the value 5 are copied into the memory location of the variable number.\"), mdx(\"p\", null, \"In addition to the above, the variable number is not a straightforward memory location or a box. The value of the variable number is a memory address -- the information about the variable type, included in the variable, tells how much data should be retrieved from the specified address. In the case of an integer this amount is 32 bits, for instance.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#value-types","title":"Value types"},{"url":"#reference-types","title":"Reference types"},{"url":"#value-or-reference-type-variable-as-a-method-parameter","title":"Value or reference type variable as a method parameter"}]},"frontmatter":{"title":"Variable types"}}},"pageContext":{"id":"6ced0495-4cfc-54bb-95dc-f7d6077a9359"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}