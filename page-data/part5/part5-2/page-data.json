{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/part5/part5-2",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Overloading methods and constructors\",\n  \"nav_order\": 2,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Let's get back to the Person class once more. Let's look a bit different version of the class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Person\\n{\\n  private string name;\\n  private int age;\\n  private double weight;\\n  private double height;\\n\\n\\n  public Person(string name)\\n  {\\n    this.name = name;\\n    this.age = 0;\\n    this.weight = 0;\\n    this.height = 0;\\n  }\\n\\n  public double BodyMassIndex()\\n  {\\n    double heigthPerHundred = this.height / 100.0;\\n    return this.weight / (heigthPerHundred * heigthPerHundred);\\n  }\\n\\n  public bool IsAdult()\\n  {\\n    if (this.age < 18)\\n    {\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  public void GrowOlder()\\n  {\\n    this.age++;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.name + \\\", age: \\\" + this.age;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Initially all person objects are 0 years old, because the constructor sets the value of the instance variable age to 0:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public Person(string name)\\n{\\n  this.name = name;\\n  this.age = 0;\\n  this.weight = 0;\\n  this.height = 0;\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"constructor-overloading\"\n  }, \"Constructor overloading\"), mdx(\"p\", null, \"We would like to also be able to create Persons so that the constructor is given the age as well as the name as parameters. This is possible, because a class can have multiple constructors. Let's make an alternative constructor. You don't have to delete the old constructor.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public Person(string name)\\n{\\n  this.name = name;\\n  this.age = 0;\\n  this.weight = 0;\\n  this.height = 0;\\n}\\n\\n    public Person(string name, int age)\\n{\\n  this.name = name;\\n  this.age = age;\\n  this.weight = 0;\\n  this.height = 0;\\n}\\n\")), mdx(\"p\", null, \"Now we have two alternative ways to create objects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Person paul = new Person(\\\"Paul\\\", 24);\\n  Person ada = new Person(\\\"Ada\\\");\\n  \\n  Console.WriteLine(paul);\\n  Console.WriteLine(ada);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Paul, age: 24\\nAda, age: 0\\n\")), mdx(\"p\", null, \"This technique, where a class has two (or more) constructors, is called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"constructor overloading\"), \". A class can have multiple constructors which differ on the amount or type of their parameters. It is however not possible to have two constructor with exactly the same parameters. We cannot for example now add a constructor public \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person(String name, int weight)\"), \" because it is impossible for the compiler to differentiate this constructor with two parameters from the constructor where the int parameter means age.\"), mdx(\"h2\", {\n    \"id\": \"calling-your-constructor\"\n  }, \"Calling your constructor\"), mdx(\"p\", null, \"As you might have noticed, there is plenty of \\\"copy-paste\\\" code in our overloaded constructors, meaning that there is repetition of same lines over and over again. When you look at the overloaded constructors above, they have a lot of the same code. We are not happy with this. If we had even more constructors, we would have to have the lines \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this.name...\"), \" in each constructor.\"), mdx(\"p\", null, \"The first constructor, the one that is only given a name as a parameter,is actually a special case of the second constructor, which is given both name and age. What if the first constructor could call the second constructor?\"), mdx(\"p\", null, \"That is no problem, because you can call a constructor from another constructor using the this keyword tied to this exact object!\"), mdx(\"p\", null, \"Let's modify the first constructor so, that it does not do anything itself, but calls the second constructor and asks it to set the age to 0.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"//here the code of the second constructor is run, and the age is set to 0\\npublic Person(string name) : this(name, 0)\\n{\\n}\\n\\npublic Person(string name, int age)\\n{\\n  this.name = name;\\n  this.age = age;\\n  this.weight = 0;\\n  this.height = 0;\\n}\\n\")), mdx(\"p\", null, \"The constructor call \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this(name, 0)\"), \" might seem a bit weird. We can use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" to have one constructor invocation call another constructor method, whic reduces \\\"copy-paste code\\\". In the example above, you could imagine the upper constuctor calling the lower one, with values \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"name\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"0\"), \". As the lower constructor already defines how those values are to be treated, there is no need to separately define the variables in the upper constructor. This kind of constructor call does not change the code's behavior, and new objects can be created just like before:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Person paul = new Person(\\\"Paul\\\", 24);\\n  Person ada = new Person(\\\"Ada\\\");\\n  \\n  Console.WriteLine(paul);\\n  Console.WriteLine(ada);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Paul, age: 24\\nAda, age: 0\\n\")), mdx(\"h2\", {\n    \"id\": \"method-overloading\"\n  }, \"Method overloading\"), mdx(\"p\", null, \"Like constructors, methods can also be overloaded, so you can have multiple versions of one method. Again, the parameters of the different versions must be different. Let's make another version of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GrowOlder\"), \" method, which ages the person the amount of years given to it as a parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public void GrowOlder()\\n{\\n  this.age++;\\n}\\n\\npublic void GrowOlder(int years)\\n{\\n  this.age += years;\\n}\\n\")), mdx(\"p\", null, \"Below \\\"Paul\\\" is born 24 years old, first ages one year and then ages 10 years:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Person paul = new Person(\\\"Paul\\\", 24);\\n  Console.WriteLine(paul);\\n  paul.GrowOlder();\\n  Console.WriteLine(paul);\\n  paul.GrowOlder(10);\\n  Console.WriteLine(paul);\\n\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Paul, age: 24\\nPaul, age: 25\\nPaul, age: 35\\n\")), mdx(\"p\", null, \"A Person now has two methods called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GrowOlder\"), \". Which one is executed debends on the amount of parameters given.\"), mdx(\"p\", null, \"We can also modify the program so, that the method without parameters is implemented using the method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GrowOlder(int years)\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public void GrowOlder()\\n{\\n  this.GrowOlder(1);\\n}\\n\\npublic void GrowOlder(int years)\\n{\\n  this.age += years;\\n}\\n\")), mdx(\"p\", null, \"The calling of an overloaded method is a bit different than that of an overloaded constructor. The idea is still exactly the same. Rather than having the same code in two places, we use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" and tell what we are calling. \"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"You cannot use the same notation which we used on a constructor, nor can you use this notation on a constructor. You can try what happens (or which kind of errors you get).\"), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Exercise, {\n    title: '004 Constructor overload',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"The exercise template has a class Product, which represents a product in a shop. Every product has a name, location and weight.\"), mdx(\"p\", null, \"Add the following three constructors to the Product class:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public Product(string name)\"), \" creates a product with the given name. Its location is set to \\\"shelf\\\" and its weight is set to 1.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public Product(string name, string location)\"), \" creates a product with the given name and the given location. Its weight is set to 1.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public Product(string name, int weight)\"), \" creates a product with the given name and the given weight. Its location is set to \\\"warehouse\\\".\\nYou can test your program with the following code:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Product tapeMeasure = new Product(\\\"Tape measure\\\");\\nProduct plaster = new Product(\\\"Plaster\\\", \\\"home improvement section\\\");\\nProduct tyre = new Product(\\\"Tyre\\\", 5);\\n\\nConsole.WriteLine(tapeMeasure);\\nConsole.WriteLine(plaster);\\nConsole.WriteLine(tyre);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Tape measure (1 kg) can be found from the shelf. \\nPlaster (1 kg) can be found from the home improvement section. \\nTyre (5 kg) can be found from the warehouse.\\n\"))), mdx(Exercise, {\n    title: '005 Overloaded counter',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Implement a class called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Counter\"), \". The class contains a number, whichs value can be increased and decreased. The class must have the following constructors:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public Counter(int startValue)\"), \" sets the start value of the counter to startValue.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public Counter()\"), \" sets the start value of the counter to 0.\"))), mdx(\"p\", null, \"And the following methods and properties:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public int value { get; set; }\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Increase()\"), \" increases the value by 1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Decrease()\"), \" decreases the value by 1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Increase(int increaseBy)\"), \" increases the value of the counter by the value of increaseBy. If the value of increaseBy is negative, the value of the counter does not change.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Decrease(int decreaseBy)\"), \" decreases the value of the counter by the value of decreaseBy. If the value of decreaseBy is negative, the value of the counter does not change.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#constructor-overloading","title":"Constructor overloading"},{"url":"#calling-your-constructor","title":"Calling your constructor"},{"url":"#method-overloading","title":"Method overloading"}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"Overloading methods and constructors"}}},"pageContext":{"id":"57741168-3d71-55e6-98e5-e16abbf8fad0"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}