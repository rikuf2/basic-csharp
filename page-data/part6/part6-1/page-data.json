{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/part6/part6-1",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"User Interfaces\",\n  \"nav_order\": 1,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"separating-the-user-interface-from-program-logic\"\n  }, \"Separating the user interface from program logic\"), mdx(\"p\", null, \"Let's examine the process of implementing a program and separating different areas of responsibility from each other. The program asks the user to write words until they write the same word twice.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Write a word:\\n> carrot \\nWrite a word:\\n> turnip \\nWrite a word:\\n> potato \\nWrite a word:\\n> celery \\nWrite a word:\\n> potato \\nYou wrote the same word twice!\\n\")), mdx(\"p\", null, \"Let's build this program piece by piece. One of the challenges is that it is difficult to decide how to approach the problem, or how to split the problem into smaller subproblems, and from which subproblem to start. There is no one clear answer -- sometimes it is good to start from the problem domain and its concepts and their connections, sometimes it is better to start from the user interface.\"), mdx(\"p\", null, \"We could start implementing the user interface by creating a class UserInterface. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class UserInterface\\n{\\n  public UserInterface() \\n  {\\n\\n  }\\n\\n  public void Start()\\n  {\\n    // Do something...\\n  }\\n}\\n\")), mdx(\"p\", null, \"Creating and starting up a user interface can be done as follows.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args) \\n{  \\n  UserInterface userinterface = new UserInterface();\\n  userinterface.Start();\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"looping-and-quitting\"\n  }, \"Looping and quitting\"), mdx(\"p\", null, \"This program has (at least) two \\\"sub-problems\\\". The first problem is continuously reading words from the user until a certain condition is reached. We can outline this as follows.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class UserInterface\\n{\\n  public UserInterface() \\n  {\\n\\n  }\\n\\n  public void Start()\\n  {\\n    while(true)\\n    {\\n      Console.WriteLine(\\\"Enter a word:\\\");\\n      string word = Console.ReadLine();\\n\\n      if(/*stop condition here*/) {\\n        break;\\n      }\\n    }\\n    Console.WriteLine(\\\"You gave the same word twice!\\\");\\n  }\\n}\\n\")), mdx(\"p\", null, \"The program continues to ask for words until the user enters a word that has already been entered before. Let us modify the program so that it checks whether the word has been entered or not. We don't know yet how to implement this functionality, so let us first build an outline for it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class UserInterface\\n{\\n  public UserInterface() \\n  {\\n\\n  }\\n\\n  public void Start()\\n  {\\n    while(true)\\n    {\\n      Console.WriteLine(\\\"Enter a word:\\\");\\n      string word = Console.ReadLine();\\n      if(AlreadyEntered(word)) {\\n        break;\\n      }\\n    }\\n    Console.WriteLine(\\\"You gave the same word twice!\\\");\\n  }\\n}\\n\\n  public bool AlreadyEntered(string word) \\n  {\\n    // do something here\\n    return false;\\n  }\\n}\\n\")), mdx(\"p\", null, \"It's a good idea to test the program continuously, so let's make a test version of the method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public bool AlreadyEntered(string word) \\n{\\n  if (word == \\\"end\\\") \\n  {\\n    return true;\\n  }\\n  return false;\\n}\\n\")), mdx(\"p\", null, \"Now the loop continues until the input equals the word \\\"end\\\":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Write a word:\\n> carrot \\nWrite a word:\\n> turnip \\nWrite a word:\\n> potato \\nWrite a word:\\n> celery \\nWrite a word:\\n> end\\nYou wrote the same word twice!\\n\")), mdx(\"p\", null, \"The program doesn't completely work yet, but the first sub-problem - quitting the loop when a certain condition has been reached - has now been implemented.\"), mdx(\"h2\", {\n    \"id\": \"storing-relevant-information\"\n  }, \"Storing relevant information\"), mdx(\"p\", null, \"Another sub-problem is remembering the words that have already been entered. A list is a good structure for this purpose.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class UserInterface\\n{\\n  private List<string> words;\\n\\n  public UserInterface() \\n  {\\n    this.words = new List<string>();\\n  }\\n\\n  public void Start()\\n  {\\n    while(true)\\n    {\\n      Console.WriteLine(\\\"Enter a word:\\\");\\n      string word = Console.ReadLine();\\n\\n      if(AlreadyEntered(word)) {\\n        break;\\n      }\\n    }\\n    Console.WriteLine(\\\"You gave the same word twice!\\\");\\n  }\\n  public bool AlreadyEntered(string word) \\n  {\\n    if (word == \\\"end\\\") \\n    {\\n      return true;\\n    }\\n    return false;\\n  }\\n}\\n\")), mdx(\"p\", null, \"When a new word is entered, it has to be added to the list of words that have been entered before. This is done by adding a line that updates our list to the while-loop:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"while(true)\\n{\\n  Console.WriteLine(\\\"Enter a word:\\\");\\n  string word = Console.ReadLine();\\n\\n  if (AlreadyEntered(word))\\n  {\\n    break;\\n  }\\n  // adding the word to the list of previous words\\n  this.words.Add(word);\\n}\\n\")), mdx(\"p\", null, \"The whole user interface now looks as follows.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class UserInterface\\n{\\n  private List<string> words;\\n\\n  public UserInterface() \\n  {\\n    this.words = new List<string>();\\n  }\\n\\n  public void Start()\\n  {\\n    while(true)\\n    {\\n      Console.WriteLine(\\\"Enter a word:\\\");\\n      string word = Console.ReadLine();\\n\\n      if (AlreadyEntered(word))\\n      {\\n        break;\\n      }\\n      // adding the word to the list of previous words\\n      this.words.Add(word);\\n    }\\n    Console.WriteLine(\\\"You gave the same word twice!\\\");\\n  }\\n\\n  public bool AlreadyEntered(string word) \\n  {\\n    if (word == \\\"end\\\") \\n    {\\n      return true;\\n    }\\n    return false;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Again, it is a good idea to test that the program still works. For example, it might be useful to add a test print to the end of the start-method to make sure that the entered words have really been added to the list.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// test print to check that everything still works\\nwords.ForEach(Console.WriteLine);\\n\")), mdx(\"h2\", {\n    \"id\": \"combining-the-solutions-to-sub-problems\"\n  }, \"Combining the solutions to sub-problems\"), mdx(\"p\", null, \"Let's change the method 'AlreadyEntered' so that it checks whether the entered word is contained in our list of words that have been already entered.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public bool AlreadyEntered(string word) \\n{\\n  return this.words.Contains(word);\\n}\\n\")), mdx(\"p\", null, \"Now the application works as intended.\"), mdx(\"h2\", {\n    \"id\": \"objects-as-a-natural-part-of-problem-solving\"\n  }, \"Objects as a natural part of problem solving\"), mdx(\"p\", null, \"We just built a solution to a problem where the program reads words from a user until the user enters a word that has already been entered before. Our example input was as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Write a word:\\n> carrot \\nWrite a word:\\n> turnip \\nWrite a word:\\n> potato \\nWrite a word:\\n> celery \\nWrite a word:\\n> potato \\nYou wrote the same word twice!\\n\")), mdx(\"p\", null, \"We came up with the following solution:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class UserInterface\\n{\\n  private List<string> words;\\n\\n  public UserInterface() \\n  {\\n    this.words = new List<string>();\\n  }\\n\\n  public void Start()\\n  {\\n    while(true)\\n    {\\n      Console.WriteLine(\\\"Enter a word:\\\");\\n      string word = Console.ReadLine();\\n\\n      if (AlreadyEntered(word))\\n      {\\n        break;\\n      }\\n      // adding the word to the list of previous words\\n      this.words.Add(word);\\n    }\\n    Console.WriteLine(\\\"You gave the same word twice!\\\");\\n  }\\n\\n  public bool AlreadyEntered(string word) \\n  {\\n    return this.words.Contains(word);\\n  }\\n}\\n\")), mdx(\"p\", null, \"From the point of view of the user interface, the support variable 'words' is just a detail. The main thing is that the user interface remembers the set of words that have been entered before. The set is a clear distinct \\\"concept\\\" or an abstraction. Distinct concepts like this are all potential objects: when we notice that we have an abstraction like this in our code, we can think about separating the concept into a class of its own.\"), mdx(\"h2\", {\n    \"id\": \"word-set\"\n  }, \"Word set\"), mdx(\"p\", null, \"Let's make a class called 'WordSet'. After implenting the class, the user interface's start method looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"while(true)\\n{\\n  if (words.Contains(word))\\n  {\\n    break;\\n  }\\n  wordSet.Add(word);\\n}\\nConsole.WriteLine(\\\"You gave the same word twice!\\\");\\n\")), mdx(\"p\", null, \"From the point of view of the user interface, the class WordSet should contain the method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"bool Contains(string word)\"), \", that checks whether the given word is contained in our set of words, and the method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"void Add(String word)\"), \", that adds the given word into the set.\"), mdx(\"p\", null, \"We notice that the readability of the user interface is greatly improved when it's written like this.\"), mdx(\"p\", null, \"The outline for the class 'WordSet' looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class WordSet \\n{\\n  // object variable(s)\\n\\n  public WordSet() \\n  {\\n    // constructor\\n  }\\n\\n  public bool Contains(string word) \\n  {\\n    // implementation of the contains method\\n    return false;\\n  }\\n\\n  public void Add(string word) \\n  {\\n    // implementation of the add method\\n  }\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"earlier-solution-as-part-of-implementation\"\n  }, \"Earlier solution as part of implementation\"), mdx(\"p\", null, \"We can implement the set of words by making our earlier solution, the list, into an object variable:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class WordSet \\n{\\n  private List<string> words;\\n\\n  public WordSet() \\n  {\\n    this.words = new List<string>();\\n  }\\n\\n  public bool Contains(string word) \\n  {\\n    return this.words.Contains(word);\\n  }\\n\\n  public void Add(string word) \\n  {\\n    this.words.Add(word);\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now our solution is quite elegant. We have separated a distinct concept into a class of its own, and our user interface looks clean. All the \\\"dirty details\\\" have been encapsulated neatly inside an object.\"), mdx(\"p\", null, \"Let's now edit the user interface so that it uses the class WordSet. The class is given to the user interface as a parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class UserInterface\\n{\\n  private WordSet wordSet;\\n\\n  public UserInterface(WordSet wordSet) \\n  {\\n    this.wordSet = wordSet;\\n  }\\n\\n  public void Start()\\n  {\\n    while(true)\\n    {\\n      Console.WriteLine(\\\"Enter a word:\\\");\\n      string word = Console.ReadLine();\\n\\n      if (this.wordSet.Contains(word))\\n      {\\n        break;\\n      }\\n      // adding the word to the list of previous words\\n      this.wordSet.Add(word);\\n    }\\n    Console.WriteLine(\\\"You gave the same word twice!\\\");\\n  }\\n}\\n\")), mdx(\"p\", null, \"Starting the program is now done as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args) \\n{  \\n  WordSet set = new WordSet();\\n  UserInterface userinterface = new UserInterface(set);\\n  userinterface.Start();\\n}  \\n\")), mdx(\"h2\", {\n    \"id\": \"changing-the-implementation-of-a-class\"\n  }, \"Changing the implementation of a class\"), mdx(\"p\", null, \"We have arrived at a situation where the class 'WordSet' \\\"encapsulates\\\" a List. Is this reasonable? Perhaps. This is because we can make other changes to the class if we so desire, and before long we might arrive into a situation where the word set has to be, for example, saved into a file. If we make all these changes inside the class WordSet without changing the names of the methods that the user interface uses, we don't have to modify the actual user interface at all.\"), mdx(\"p\", null, \"The main point here is that changes made inside the class WordSet don't affect the class UserInterface. This is because the user interface uses WordSet through the methods that it provides -- these are called its public interfaces.\"), mdx(\"h2\", {\n    \"id\": \"implementing-new-functionality-palindromes\"\n  }, \"Implementing new functionality: palindromes\"), mdx(\"p\", null, \"In the future, we might want to augment the program so that the class 'WordSet' offers some new functionalities. If, for example, we wanted to know how many of the entered words were palindromes, we could add a method called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Palindromes\"), \" into the program.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public void Start()\\n{\\n  while(true)\\n  {\\n    Console.WriteLine(\\\"Enter a word:\\\");\\n    string word = Console.ReadLine();\\n\\n    if (this.wordSet.Contains(word))\\n    {\\n      break;\\n    }\\n    // adding the word to the list of previous words\\n    this.wordSet.Add(word);\\n  }\\n  Console.WriteLine(\\\"You gave the same word twice!\\\");\\n  Console.WriteLine(this.wordSet.Palindromes() + \\\" of the words were palindromes.\\\");\\n}\\n\")), mdx(\"p\", null, \"The user interface remains clean, because counting the palindromes is done inside the 'WordSet' object. The following is an example implementation of the method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public int Palindromes() \\n{\\n  int count = 0;\\n\\n  foreach (string word in this.words)) \\n  {\\n    if (IsPalindrome(word)) \\n    {\\n      count++;\\n    }\\n  }\\n\\n  return count;\\n}\\n\\npublic bool IsPalindrome(string word) \\n{\\n  int length = word.Length;\\n  int end = word.Length - 1;\\n  for (int i = 0; i < length / 2; i++)\\n  {\\n      if (word[i] != word[end - i])\\n          return false;\\n  }\\n  return true;\\n}\\n\")), mdx(\"p\", null, \"The method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Palindromes\"), \" uses the helper method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IsPalindrome\"), \" to check whether the word that's given to it as a parameter is, in fact, a palindrome.\"), mdx(\"p\", null, \"When concepts have been separated into different classes in the code, recycling them and reusing them in other projects becomes easy. For example, the class 'WordSet' could be well be used in a graphical user interface, and it could also part of a mobile phone application. In addition, testing the program is much easier when it has been divided into several concepts, each of which has its own separate logic and can function alone as a unit.\"), mdx(\"h2\", {\n    \"id\": \"programming-tips\"\n  }, \"Programming tips\"), mdx(\"p\", null, \"In the larger example above, we were following the advice given here.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Proceed with small steps\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Try to separate the program into several sub-problems and work on only one sub-problem at a time\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Always test that the program code is advancing in the right direction, in other words: test that the solution to the sub-problem is correct\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Recognize the conditions that require the program to work differently. In the example above, we needed a different functionality to test whether a word had been already entered before.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Write as \\\"clean\\\" code as possible\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Indent your code\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use descriptive method and variable names\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Don't make your methods too long, not even the main method\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Do only one thing inside one method\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Remove all copy-paste code\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Replace the \\\"bad\\\" and unclean parts of your code with clean code\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If needed, take a step back and assess the program as a whole. If it doesn't work, it might be a good idea to return into a previous state where the code still worked. As a corollary, we might say that a program that's broken is rarely fixed by adding more code to it.\"))), mdx(\"p\", null, \"Programmers follow these conventions so that programming can be made easier. Following them also makes it easier to read programs, to keep them up, and to edit them in teams.\"), mdx(\"h2\", {\n    \"id\": \"from-one-entity-to-many-parts\"\n  }, \"From one entity to many parts\"), mdx(\"p\", null, \"Let's examine a program that asks the user to enter exam points and turns them into grades. Finally, the program prints the distribution of the grades as stars. The program stops reading inputs when the user inputs an empty string. An example program looks as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Points:\\n> 91 \\nPoints:\\n> 98 \\nPoints:\\n> 103 \\nImpossible number. \\nPoints:\\n> 90 \\nPoints:\\n> 89 \\nPoints:\\n> 89 \\nPoints:\\n> 88 \\nPoints:\\n> 72 \\nPoints:\\n> 54 \\nPoints:\\n> 55 \\nPoints: \\n51 \\nPoints:\\n> 49 \\nPoints:\\n> 48 \\nPoints:\\n>\\n\\n5: *** \\n4: *** \\n3: * \\n2: \\n1: *** \\n0: **\\n\")), mdx(\"p\", null, \"As almost all programs, this program can be written into main as one entity. Here is one possibility.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Program \\n{\\n  public static void Main(string[] args) \\n  {\\n    List<int> grades = new List<int>();\\n\\n    while (true) {\\n      Console.WriteLine(\\\"Points:\\\");\\n      string input = Console.ReadLine();\\n      if (input == \\\"\\\") \\n      {\\n          break;\\n      }\\n      int score = Conver.ToInt32(input);\\n\\n      if (score < 0 || score > 100) \\n      {\\n        Console.WriteLine(\\\"Impossible number.\\\");\\n        continue;\\n      }\\n\\n      int grade = 0;\\n      if (score < 50) \\n      {\\n        grade = 0;\\n      } \\n      else if (score < 60) \\n      {\\n        grade = 1;\\n      } \\n      else if (score < 70) \\n      {\\n        grade = 2;\\n      } \\n      else if (score < 80) \\n      {\\n        grade = 3;\\n      } \\n      else if (score < 90) \\n      {\\n        grade = 4;\\n      } \\n      else \\n      {\\n        grade = 5;\\n      }\\n\\n      grades.Add(grade);\\n    }\\n\\n    Console.WriteLine(\\\"\\\");\\n    int grade = 5;\\n    while (grade >= 0) \\n    {\\n      int stars = 0;\\n      foreach(int received in grades) \\n      {\\n        if (received == grade) \\n        {\\n          stars++;\\n        }\\n      }\\n\\n      Console.Write(grade + \\\": \\\");\\n      while (stars > 0) \\n      {\\n        Console.Write(\\\"*\\\");\\n        stars--;\\n      }\\n      Console.WriteLine(\\\"\\\");\\n      grade = grade - 1;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Let's separate the program into smaller chunks. This can be done by identifying several discrete areas of responsibility within the program. Keeping track of grades, including converting scores into grades, could be done inside a different class. In addition, we could create a new class for the user interface.\"), mdx(\"h2\", {\n    \"id\": \"program-logic\"\n  }, \"Program logic\"), mdx(\"p\", null, \"Program logic includes parts that are crucial for the execution of the program, like functionalities that store information. From the previous example, we can separate the parts that store grade information. From these we can make a class called 'GradeRegister', which is responsible for keeping track of the numbers of different grades students have received. In the register, we can add grades according to scores. In addition, we can use the register to ask how many people have received a certain grade.\"), mdx(\"p\", null, \"An example class follows.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class GradeRegister \\n{\\n  private List<int> grades;\\n  \\n  public GradeRegister() \\n  {\\n    this.grades = new List<int>();\\n  }\\n\\n  public void AddGradeBasedOnPoints(int points) \\n  {\\n    this.grades.add(PointsToGrades(points));\\n  }\\n\\n  public int NumberOfGrades(int grade) \\n  {\\n    int count = 0;\\n    foreach(int received in this.grades) \\n    {\\n      if (received == grade) \\n      {\\n          count++;\\n      }\\n    }\\n    return count;\\n  }\\n  \\n  public static int PointsToGrades(int points) \\n  {\\n    int grade = 0;\\n    if (points < 50) \\n    {\\n      grade = 0;\\n    } \\n    else if (points < 60) \\n    {\\n      grade = 1;\\n    } \\n    else if (points < 70) \\n    {\\n      grade = 2;\\n    } \\n    else if (points < 80) \\n    {\\n      grade = 3;\\n    } \\n    else if (points < 90) \\n    {\\n      grade = 4;\\n    } \\n    else \\n    {\\n      grade = 5;\\n    }\\n    return grade;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"When the grade register has been separated into a class, we can remove the functionality associated with it from our main program. The main program now looks like this.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Program \\n{\\n  public static void Main(string[] args) \\n  {\\n    GradeRegister register = new GradeRegister();\\n\\n    while (true) {\\n      Console.WriteLine(\\\"Points:\\\");\\n      string input = Console.ReadLine();\\n      if (input == \\\"\\\") \\n      {\\n          break;\\n      }\\n      int score = Conver.ToInt32(input);\\n\\n      if (score < 0 || score > 100) \\n      {\\n        Console.WriteLine(\\\"Impossible number.\\\");\\n        continue;\\n      }\\n      register.AddGradeBasedOnPoints(score);\\n    }\\n\\n    Console.WriteLine(\\\"\\\");\\n    int grade = 5;\\n    while (grade >= 0) \\n    {\\n      int stars = register.NumberOfGrades(grade);\\n      Console.Write(grade + \\\": \\\");\\n      while (stars > 0) \\n      {\\n        Console.Write(\\\"*\\\");\\n        stars--;\\n      }\\n      Console.WriteLine(\\\"\\\");\\n\\n      grade = grade - 1;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Separating the program logic is a major benefit for the maintenance of the program. Since the program logic -- in this case the GradeRegister -- is its own class, it can also be tested separately from the other parts of the program. If you wanted to, you could copy the class GradeRegister and use it in your other programs. Below is an example of simple manual testing -- this experiment only concerns itself with a small part of the register's functionality.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"GradeRegister register = new GradeRegister();\\nregister.AddGradeBasedOnPoints(51);\\nregister.AddGradeBasedOnPoints(50);\\nregister.AddGradeBasedOnPoints(49);\\n\\nConsole.WriteLine(\\\"Number of students with grade 0 (should be 1): \\\" + register.NumberOfGrades(0));\\nConsole.WriteLine(\\\"Number of students with grade 1 (should be 2): \\\" + register.NumberOfGrades(1));\\n\")), mdx(\"h2\", {\n    \"id\": \"user-interface\"\n  }, \"User interface\"), mdx(\"p\", null, \"Typically each program has its own user interface. We will create the class UserInterface and separate it from the main program. The user interface receives a grade register for storing the grades as a parameter for the constructor.\"), mdx(\"p\", null, \"When we now have a separate user interface at our disposal, the main program that initializes the whole program becomes very clear.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Program \\n{\\n  public static void Main(String[] args) \\n  {\\n    GradeRegister register = new GradeRegister();\\n\\n    UserInterface userInterface = new UserInterface(register);\\n    userInterface.Start();\\n  }\\n}\\n\")), mdx(\"p\", null, \"Let's have a look at how the user interface is implemented. There are two essential parts to the UI: reading the points, and printing the grade distribution.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class UserInterface \\n{\\n  private GradeRegister register;\\n\\n  public UserInterface(GradeRegister register) \\n  {\\n    this.register = register;\\n  }\\n\\n  public void Start() \\n  {\\n    ReadPoints();\\n    Console.WriteLine(\\\"\\\");\\n    PrintGradeDistribution();\\n  }\\n\\n  public void ReadPoints() \\n  {\\n  }\\n\\n  public void PrintGradeDistribution() \\n  {\\n  }\\n}\\n\")), mdx(\"p\", null, \"We can copy the code for reading exam points and printing grade distribution nearly as is from the previous main program. In the program below, parts of the code have indeed been copied from the earlier main program, and new method for printing stars has also been created -- this clarifies the method that is used for printing the grade distribution.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class UserInterface \\n{\\n  private GradeRegister register;\\n\\n  public UserInterface(GradeRegister register) \\n  {\\n    this.register = register;\\n  }\\n\\n  public void Start() \\n  {\\n    ReadPoints();\\n    Console.WriteLine(\\\"\\\");\\n    PrintGradeDistribution();\\n  }\\n\\n  public void ReadPoints() \\n  {\\n    while (true) \\n    {\\n      Console.WriteLine(\\\"Points:\\\");\\n      string input = Console.ReadLine();\\n      if (input =0 \\\"\\\") \\n      {\\n        break;\\n      }\\n      int score = Conver.ToInt32(input);\\n\\n      if (score < 0 || score > 100) \\n      {\\n        Console.WriteLine(\\\"Impossible number.\\\");\\n        continue;\\n      }\\n      register.AddGradeBasedOnPoints(score);\\n    }\\n  }\\n\\n  public void PrintGradeDistribution() \\n  {\\n    int grade = 5;\\n    while (grade >= 0) \\n    {\\n      int stars = register.NumberOfGrades(grade);\\n      Console.Write(grade + \\\": \\\");\\n      PrintStars(stars);\\n      Console.WriteLine();\\n\\n      grade = grade - 1;\\n    }\\n\\n  public static void PrintStars(int stars) \\n  {\\n    while (stars > 0) \\n    {\\n      Console.Write(\\\"*\\\");\\n      stars--;\\n    }\\n  }\\n  }\\n}\\n\")), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Exercise, {\n    title: '001 Grade register',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"The exercise base contains the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GradeRegister\"), \" from the material. In this exercise you will further develop the program, so that it can calculate the average of grades and exam results.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 1 - Average grade\")), mdx(\"p\", null, \"create the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public double AverageOfGrades()\"), \" for the class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GradeRegister\"), \". It should return the average of the grades, rounded to 2 decimals. If the register contains no grades, the method should return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-1\"), \". Use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"grades\"), \" list to calculate the average. Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"GradeRegister register = new GradeRegister();\\nregister.AddGradeBasedOnPoints(93);\\nregister.AddGradeBasedOnPoints(91);\\nregister.AddGradeBasedOnPoints(92);\\nregister.AddGradeBasedOnPoints(88);\\n\\nConsole.WriteLine(register.AverageOfGrades());\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"4.75\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 2 - Average points\")), mdx(\"p\", null, \"Give the class GradeRegister a new object variable: a list where you will store the exam points every time that the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddGradeBasedOnPoints\"), \" is called. After this addition, create a method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public double AverageOfPoints()\"), \" that calculates and returns the average of the exam points, rounded to 2 decimals. If there are no points added to the register, the method should return the number -1. Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"GradeRegister register = new GradeRegister();\\nregister.AddGradeBasedOnPoints(93);\\nregister.AddGradeBasedOnPoints(91);\\nregister.AddGradeBasedOnPoints(92);\\n\\nConsole.WriteLine(register.AverageOfPoints());\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"92\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 3 - Prints in the user interface\")), mdx(\"p\", null, \"As a final step, add the methods implemented above as parts of the user interface. When the program prints the grade distribution, it should also print the averages of the points and the grades.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Points:\\n> 82 \\nPoints:\\n> 83\\nPoints:\\n> 96 \\nPoints: \\n> 51 \\nPoints:\\n> 48 \\nPoints:\\n> 56 \\nPoints:\\n> 61 \\nPoints:\\n>\\n\\n5: * \\n4: ** \\n3: \\n2: * \\n1: ** \\n0: * \\nThe average of points: 68.14\\nThe average of grades: 2.43\\n\"))), mdx(Exercise, {\n    title: '002 Joke manager',\n    mdxType: \"Exercise\"\n  }, mdx(Note, {\n    mdxType: \"Note\"\n  }, \"This exercise DOES NOT HAVE TESTS. It is up to you to decide, when the exercise is ready. I WILL CHECK THEM, SO DON'T CHEAT.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"This is worth double the points, so 4 in total (2 per section).\"), mdx(\"p\", null, \"The exercise base contains the following program that has been written \\\"in the main\\\".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\nusing System.Collections.Generic;\\n\\nnamespace Exercise002\\n{\\n  class Program\\n  {\\n    public static void Main(string[] args)\\n    {\\n      List<string> jokes = new List<string>();\\n      Console.WriteLine(\\\"What a joke!\\\");\\n\\n      while (true)\\n      {\\n        Console.WriteLine(\\\"Commands:\\\");\\n        Console.WriteLine(\\\" 1 - add a joke\\\");\\n        Console.WriteLine(\\\" 2 - draw a joke\\\");\\n        Console.WriteLine(\\\" 3 - list jokes\\\");\\n        Console.WriteLine(\\\" X - stop\\\");\\n\\n        string command = Console.ReadLine();\\n\\n        if (command == \\\"X\\\")\\n        {\\n          break;\\n        }\\n\\n        if (command == \\\"1\\\")\\n        {\\n          Console.WriteLine(\\\"Write the joke to be added:\\\");\\n          string joke = Console.ReadLine();\\n          jokes.Add(joke);\\n        }\\n        else if (command == \\\"2\\\")\\n        {\\n          Console.WriteLine(\\\"Drawing a joke.\\\");\\n\\n          if (jokes.Count == 0)\\n          {\\n            Console.WriteLine(\\\"Jokes are in short supply.\\\");\\n          }\\n          else\\n          {\\n            Random draw = new Random();\\n            int index = draw.Next(0, jokes.Count);\\n            Console.WriteLine(jokes[index]);\\n          }\\n\\n        }\\n        else if (command == \\\"3\\\")\\n        {\\n          Console.WriteLine(\\\"Printing the jokes.\\\");\\n          foreach (string joke in jokes)\\n          {\\n            Console.WriteLine(joke);\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The application is in practice a storage for jokes. You can add jokes, get a randomized joke, and the stored jokes can be printed. In this exercise the program is divided into parts in a guided manner.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 1 - Joke manager\")), mdx(\"p\", null, \"Create a class called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JokeManager\"), \" and move the functionality to manage jokes in it. The class must have a parameter-free constructor, and the following methods:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void AddJoke(string joke)\"), \" - adds a joke to the manager.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public string DrawJoke()\"), \" - chooses one joke at random and returns it. It there are no jokes stored in the joke manager, the method should return the string \\\"Jokes are in short supply.\\\".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void PrintJokes()\"), \" - prints all the jokes stored in the joke manager.\")), mdx(\"p\", null, \"An example of how to use the class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"JokeManager manager = new JokeManager();\\nmanager.AddJoke(\\\"What is red and smells of blue paint? - Red paint.\\\");\\nmanager.AddJoke(\\\"What is blue and smells of red paint? - Blue paint.\\\");\\n\\nConsole.WriteLine(\\\"Drawing jokes:\\\");\\nfor (int i = 0; i < 5; i++)\\n{\\n  Console.WriteLine(manager.DrawJoke());\\n}\\n\\nConsole.WriteLine(\\\"\\\");\\nConsole.WriteLine(\\\"Printing jokes:\\\");\\nmanager.PrintJokes();\\n\")), mdx(\"p\", null, \"Below is a possible output of the program. Notice that the jokes will probably not be drawn as in this example.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Drawing jokes: \\nWhat is blue and smells of red paint? - Blue paint. \\nWhat is red and smells of blue paint? - Red paint. \\nWhat is blue and smells of red paint? - Blue paint. \\nWhat is blue and smells of red paint? - Blue paint. \\nWhat is blue and smells of red paint? - Blue paint.\\n\\nPrinting jokes: \\nWhat is red and smells of blue paint? - Red paint. \\nWhat is blue and smells of red paint? - Blue paint.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 2 - User Interface\")), mdx(\"p\", null, \"Create a class called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserInterface\"), \" and move the UI functionality of the program there. The class must have a constructor with one parameter: an instance of the JokeManager class. In addition, the class should have the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public void Start()\"), \" that can be used to start the user interface.\"), mdx(\"p\", null, \"The user interface should provide the user with the following commands:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"X - ending: exits the method start.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1 - adding: asks the user for the joke to be added to the joke manager, and then adds it.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"2 - drawing: chooses a random joke from the joke manager and prints it. If there are no jokes in the manager, thi string \\\"Jokes are in short supply.\\\" will be printed.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"3 - printing: prints all the jokes stored in the joke manager.\")), mdx(\"p\", null, \"An example of how to use the UI:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"JokeManager manager = new JokeManager();\\nUserInterface ui = new UserInterface(manager);\\nui.Start();\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Commands: \\n 1 - add a joke \\n 2 - draw a joke \\n 3 - list jokes\\n  X - stop \\n> 1 \\nWrite the joke to be added:\\n> Did you hear about the claustrophobic astronaut? -- He just needed a little space. \\nCommands:\\n 1 - add a joke\\n 2 - draw a joke\\n 3 - list jokes \\n X - stop \\n> 3 \\nPrinting the jokes. \\nDid you hear about the claustrophobic astronaut? -- He just needed a little space. \\nCommands:\\n 1 - add a joke\\n 2 - draw a joke\\n 3 - list jokes \\n X - stop \\n> X\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#separating-the-user-interface-from-program-logic","title":"Separating the user interface from program logic","items":[{"url":"#looping-and-quitting","title":"Looping and quitting"},{"url":"#storing-relevant-information","title":"Storing relevant information"},{"url":"#combining-the-solutions-to-sub-problems","title":"Combining the solutions to sub-problems"},{"url":"#objects-as-a-natural-part-of-problem-solving","title":"Objects as a natural part of problem solving"},{"url":"#word-set","title":"Word set"},{"url":"#earlier-solution-as-part-of-implementation","title":"Earlier solution as part of implementation"},{"url":"#changing-the-implementation-of-a-class","title":"Changing the implementation of a class"},{"url":"#implementing-new-functionality-palindromes","title":"Implementing new functionality: palindromes"},{"url":"#programming-tips","title":"Programming tips"},{"url":"#from-one-entity-to-many-parts","title":"From one entity to many parts"},{"url":"#program-logic","title":"Program logic"},{"url":"#user-interface","title":"User interface"}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"User Interfaces"}}},"pageContext":{"id":"6f6c1a12-9598-58cd-9e0d-519083403282"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}