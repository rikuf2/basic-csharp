{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/part5/part5-1",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Object Oriented revision\",\n  \"nav_order\": 1,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"What is object-oriented programming all about? We'll rewind a little.\"), mdx(\"p\", null, \"Let's inspect how a clock works. The clock has three hands: hours, minutes and seconds. The second hand increments once every second, the minute hand once every sixty seconds, and the hour hand once in sixty minutes. When the value of the second hand is 60, its value is set to zero and the value of the minute hand is incremented by one. When the minute hand's value is 60, its value is set to zero and the hour hand value is incremented by one. When the hour hand value is 24, it is set to zero.\"), mdx(\"p\", null, \"Time is always printed in the form \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"hours: minutes: seconds\"), \", where the hours are represented by two digits (eg. 01 or 12), minutes by two digits, and seconds also by two digits.\"), mdx(\"p\", null, \"Below is an implementation of the clock with integer type variables (the printing could be isolated into its own method, but that has not been done here).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n\\nint hours = 0;\\nint minutes = 0;\\nint seconds = 0;\\n\\nwhile (true)\\n{\\n  // 1. Printing the time\\n  if (hours < 10)\\n  {\\n    Console.Write(\\\"0\\\");\\n  }\\n  Console.Write(hours);\\n\\n  Console.Write(\\\":\\\");\\n\\n  if (minutes < 10)\\n  {\\n    Console.Write(\\\"0\\\");\\n  }\\n  Console.Write(minutes);\\n\\n  Console.Write(\\\":\\\");\\n\\n  if (seconds < 10)\\n  {\\n    Console.Write(\\\"0\\\");\\n  }\\n  Console.Write(seconds);\\n  Console.WriteLine();\\n\\n  // 2. The second hand's progress\\n  seconds = seconds + 1;\\n\\n  // 3. The other hand's progress when necessary\\n  if (seconds > 59)\\n  {\\n    minutes = minutes + 1;\\n    seconds = 0;\\n\\n    if (minutes > 59)\\n    {\\n      hours = hours + 1;\\n      minutes = 0;\\n\\n      if (hours > 23)\\n      {\\n        hours = 0;\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"As demonstrated by reading the example above, the functioning of a  clock made up of three \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"int\"), \" variables is not very clear to someone reading through the source code. It's difficult to \\\"see\\\" what's going on. A famous \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Kent_Beck\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Programmer\")), \" remarked \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"Any fool can write code that a computer can understand .Good Programmers write code that humans can understand\\\"\"), \".\"), mdx(\"p\", null, \"The aim is to make the program more comprehensible.\"), mdx(\"p\", null, \"Since a clock hand is a clear concept in and of itself, a good idea with regard to the program's understandability would be to turn it into its own class. Let's create a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ClockHand\"), \" class describing a clock hand, which contains information about its value, upper limit (i.e. the point at which the value of the hand returns to zero), and provides methods for advancing the hand, viewing its value and printing the value in string form.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class ClockHand\\n{\\n  public int value { get; set; }\\n  public int limit { get; set; }\\n\\n  public ClockHand(int limit)\\n  {\\n    this.limit = limit;\\n    this.value = 0;\\n  }\\n\\n  public void Advance()\\n  {\\n    this.value = this.value + 1;\\n\\n    if (this.value >= this.limit)\\n    {\\n      this.value = 0;\\n    }\\n  }\\n\\n  public override string ToString()\\n  {\\n    if (this.value < 10)\\n    {\\n      return \\\"0\\\" + this.value;\\n    }\\n\\n    return \\\"\\\" + this.value;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Once we've created the ClockHand class, our clock becomes clearer. Now, printing the clock, i.e. the clock hand, is straightforward, and the hand's progression is hidden away in the ClockHand class. Since the hand's return to the beginning happens automatically with the help of the upper-limit variable defined by the ClockHand class, the way the hands work together is slightly different than in the program implementation that uses integers. The program that used integers looked at whether the value of the integer that represented the clock hand exceeded the upper limit, after which its value was set to zero and the value of the integer representing the next clock hand was incremented. Using clock-hand objects, the minute hand advances when the second hand's value is zero, and the hour hand advances when the minute hand's value is zero.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  ClockHand hours = new ClockHand(24);\\n  ClockHand minutes = new ClockHand(60);\\n  ClockHand seconds = new ClockHand(60);\\n\\n  while (true)\\n  {\\n    // 1. Printing the time\\n    Console.WriteLine(hours + \\\":\\\" + minutes + \\\":\\\" + seconds);\\n\\n    // 2. Advancing the second hand\\n    seconds.Advance();\\n\\n    // 3. Advancing the other hands when required\\n    if (seconds.value == 0)\\n    {\\n      minutes.Advance();\\n\\n      if (minutes.value == 0)\\n      {\\n        hours.Advance();\\n      }\\n    }\\n  }\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object-oriented programming is mainly about isolating concepts into their own entities or, in other words, creating abstractions.\"), \" Despite the previous example, one might see it pointless to create an object containing only a number, since the same could be done directly with int variables. However, that is not always the case.\"), mdx(\"p\", null, \"Separating a concept into its own class is a good idea in many ways. Firstly, certain details (such as rotating the hand) can be hidden inside the class (i.e. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"abstracted\"), \"). Instead of typing an if-statement and an assignment operation, it's enough for the user of the clock hand to call a clearly-named method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Advance()\"), \". The produced clock hand may be used as a building block for other programs as well - the class could be named \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CounterLimitedFromTop\"), \" for instance. That is, a class created from a distinct concept can serve multiple purposes. Another massive advantage is that since the details of the implementation of the clock hand are not visible to its user, they can be changed if desired.\"), mdx(\"p\", null, \"We realized that the clock contains three hands, i.e. it consists of three concepts. In fact, the clock is a concept in and of itself. That is, we can create a class of it as well. Next, we create a class called \\\"Clock\\\" that hides the hands inside of it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Clock\\n{\\n  private ClockHand hours;\\n  private ClockHand minutes;\\n  private ClockHand seconds;\\n\\n  public Clock()\\n  {\\n    this.hours = new ClockHand(24);\\n    this.minutes = new ClockHand(60);\\n    this.seconds = new ClockHand(60);\\n  }\\n\\n  public void Advance()\\n  {\\n    this.seconds.Advance();\\n\\n    if (this.seconds.value == 0)\\n    {\\n      this.minutes.Advance();\\n\\n      if (this.minutes.value == 0)\\n      {\\n        this.hours.Advance();\\n      }\\n    }\\n  }\\n\\n  public override string ToString()\\n  {\\n    return hours + \\\":\\\" + minutes + \\\":\\\" + seconds;\\n  }\\n}\\n\")), mdx(\"p\", null, \"The way the program functions becomes increasingly clear. When you compare the program below to the original one composed of integers, you'll find that the program's readability is on a completely different level.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Clock clock = new Clock();\\n\\n  while (true)\\n  {\\n    Console.WriteLine(clock);\\n    clock.Advance();\\n  }\\n}\\n\")), mdx(\"p\", null, \"The clock we implemented above is an object whose functionality is based on \\\"simpler\\\" objects, i.e., the hands. This is exactly \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"the great idea behind \\u200B\\u200Bobject-oriented programming: a program is built from small and distinct objects that work together.\")), mdx(\"h2\", {\n    \"id\": \"object\"\n  }, \"Object\"), mdx(\"p\", null, \"An \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object\"), \" refers to an independent entity that has data (instance variables) and behavior (methods) attached to it. Objects can differ a lot in structure and function: some may describe concepts of a problem domain, and others coordinate the interaction between various objects. Objects interact with one another through method calls - method calls are used to both request information from objects and give instructions to them. In general, each object has clearly defined boundaries and behaviors, and each object knows only about the objects it needs to perform its task. In other words, the object hides its internal operations and provides access to behavior through clearly defined methods. Also, the object is independent of any objects that it doesn't need to accomplish its task.\"), mdx(\"p\", null, \"In the previous section, we dealt with objects depicting people whose structure was defined in a \\\"Person\\\" class. For review, it's a good idea to remember the purpose of a class: a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"class\"), \" contains the blueprint needed to create objects, and also defines the objects' variables and methods. An object is instantiated based on the constructor in the class.\"), mdx(\"p\", null, \"Our person objects had a name, age, weight and height, and a few methods. If we thought about the structure of the person object more, we could probably come up with more person-related variables, such as a personal ID number, telephone number, address, and eye color.\"), mdx(\"p\", null, \"In reality, we can relate all kinds of different information and things to a person. However, when building an application that deals with people, the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"functionality and features related to a person are gathered based on the application's use case\"), \". For example, a life-management application could keep track of the previously-mentioned age, weight, and height, and provide the ability to calculate body mass index and maximum heart rate. On the other hand, an application focused on communication would store people's email addresses and phone numbers, but would not need information such as weight or height.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"The state of an object\"), \" is the value of its internal variables at any given point in time.\"), mdx(\"p\", null, \"In our example, a Person object that keeps track of name, age, weight, and height, and provides the ability to calculate body mass index and maximum heart rate would look like the following. Below, the height and weight are expressed as doubles - the unit of length is one meter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Person\\n{\\n  private string name;\\n  private int age;\\n  private double weight;\\n  private double height;\\n\\n  public Person(string name, int age, double weight, double height)\\n  {\\n    this.age = age;\\n    this.name = name;\\n    this.weight = weight;\\n    this.height = height;\\n  }\\n\\n  public double BodyMassIndex()\\n  {\\n    return this.weight / (this.height * this.height);\\n  }\\n\\n  public double MaximumHeartRate()\\n  {\\n    return 206.3 - (0.711 * this.age);\\n  }\\n\\n  public void GrowOlder()\\n  {\\n    if (this.age < 100)\\n    {\\n      this.age = this.age + 1;\\n    }\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.name + \\\", BMI: \\\" + this.BodyMassIndex()\\n          + \\\", maximum heart rate: \\\" + this.MaximumHeartRate();\\n  }\\n}\\n\")), mdx(\"p\", null, \"Determining the maximum heart rate and body mass index of a given person is straightforward using the Person class described above.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Console.WriteLine(\\\"What's your name?\\\");\\n  string name = Console.ReadLine();\\n  Console.WriteLine(\\\"What's your age?\\\");\\n  int age = Convert.ToInt32(Console.ReadLine());\\n  Console.WriteLine(\\\"What's your weight?\\\");\\n  double weight = Convert.ToDouble(Console.ReadLine());\\n  Console.WriteLine(\\\"What's your height?\\\");\\n  double height = Convert.ToDouble(Console.ReadLine());\\n\\n  Person person = new Person(name, age, weight, height);\\n  Console.WriteLine(person);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"What's your name?\\nLaura Palmer\\nWhat's your age?\\n21\\nWhat's your weight?\\n50.4\\nWhat's your height?\\n173.4\\nLaura Palmer, BMI: 0.0016762251409825073, maximum heart rate: 191.369\\n\")), mdx(\"h2\", {\n    \"id\": \"class\"\n  }, \"Class\"), mdx(\"p\", null, \"A class defines the types of objects that can be created from it. It contains instance variables describing the object's data, a constructor or constructors used to create it, and methods that define its behavior. A rectangle class is detailed below which defines the functionality of a rectangle:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// class\\npublic class Rectangle\\n{\\n\\n  // instance variables\\n  private int width;\\n  private int height;\\n\\n  // constructor\\n  public Rectangle(int width, int height)\\n  {\\n    this.width = width;\\n    this.height = height;\\n  }\\n\\n  // methods\\n  public void Widen()\\n  {\\n    this.width = this.width + 1;\\n  }\\n\\n  public void Narrow()\\n  {\\n    if (this.width > 0)\\n    {\\n      this.width = this.width - 1;\\n    }\\n  }\\n\\n  public int SurfaceArea()\\n  {\\n    return this.width * this.height;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return \\\"(\\\" + this.width + \\\", \\\" + this.height + \\\")\\\";\\n  }\\n}\\n\")), mdx(\"p\", null, \"Some of the methods defined above do not return a value (methods that have the keyword void in their definition), while others do (methods that specify the type of variable to be returned). The class above also defines the toString method, which returns the string used to print the object.\"), mdx(\"p\", null, \"Objects are created from the class through constructors by using the new command. Below, you'll create two rectangles and print information related to them.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Rectangle first = new Rectangle(40, 80);\\n  Rectangle rectangle = new Rectangle(10, 10);\\n  Console.WriteLine(first);\\n  Console.WriteLine(rectangle);\\n\\n  first.Narrow();\\n  Console.WriteLine(first);\\n  Console.WriteLine(first.SurfaceArea());\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"(40, 80)\\n(10, 10)\\n(39, 80)\\n3120\\n\")), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Exercise, {\n    title: '001 One minute',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"The exercise template comes with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ClockHand\"), \" class described in the course material. Implement a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Timer\"), \" class based on the material's Clock class.\"), mdx(\"p\", null, \"The timer has two hands, one for hundredths of a second and one for seconds. As it progresses, the number of hundredths of a second grows by one. When the hand corresponding to hundredths of a second reaches a value of 100, its value is set to zero, and the number of seconds grows by one. In the same way, when the value of the hand corresponding to seconds reaches the value of sixty, its value is set to zero.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public Timer()\"), \" creates a new timer.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public override string ToString()\"), \" returns a string representation of the timer. The string representation should be in the form \\\"seconds: hundredths of a second\\\", where both the seconds and the hundredths of a second are represented by two numbers. For example, \\\"19:83\\\" would represent the time 19 seconds, 83 hundredths of a second.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Advance()\"), \" moves the timer forward by a hundredth of a second.\")), mdx(\"p\", null, \"You can test out the timer's functionality in the main program whenever you like. The example code below provides you with a program where the timer is printed and it advances once every hundredth of a second.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  // create new timer\\n  Timer timer = new Timer();\\n  // Loop until you cancel the loop.\\n  // You can cancel with the CTRL + C\\n  while (true)\\n  {\\n    Console.WriteLine(timer);\\n    timer.Advance();\\n    // Some error proving, we'll talk about this later.\\n    // Known as try-catch.\\n    try\\n    {\\n      // Wait 100th of a second. \\n      // Sleep(1000) waits one second, if you want to test at slower pace.\\n      System.Threading.Thread.Sleep(10);\\n    }\\n    // Other half of try-catch pair. \\n    catch (Exception e)\\n    {\\n      Console.WriteLine(\\\"Error happened: +\\\" + e);\\n    }\\n  }\\n}\\n\"))), mdx(Exercise, {\n    title: '002 Cube',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cube\"), \" class that represents a cube (i.e., a standard hexahedron). create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public Cube (int edgeLength)\"), \" constructor for the class, that takes the length of the cube's edge as its parameter.\"), mdx(\"p\", null, \"Make a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public int Volume()\"), \" method for the cube, which calculates and returns the cube's volume. The volume of the cube is calculated with the formula \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"edgeLength * edgeLength * edgeLength\"), \". Moreover, make a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public override string ToString()\"), \" method for the cube, which returns a string representation of it. The string representation should take the form \\\"The length of the edge is l and the volume v\\\", where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"l\"), \" is the length and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"v\"), \" the volume - both the length and volume must be represented as integers.\")), mdx(Exercise, {\n    title: '003 Fitbyte',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Heart_rate#Karvonen_method\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"The Karvonen method\")), \" allows you to calculate your target heart rate for physical exercise. The target heart rate is calculated with the formula \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(maximum heart rate - resting heart rate) * (target heart rate percentage) + resting heart rate\"), \", where the target heart rate is given as a percentage of the maximum heart rate.\"), mdx(\"p\", null, \"For example, if a person has a maximum heart rate of 200, a resting heart rate of 50, and a target heart rate of 75% of the maximum heart rate, the target heart rate should be about ((200-50) * (0.75) + 50), i.e., 162.5 beats per minute.\"), mdx(\"p\", null, \"create an \\\"exercise assistant\\\" class called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fitbyte\"), \". Its constructor takes both an age and a resting heart rate as its parameters. The exercise assistant should provide a method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TargetHeartRate\"), \", which is passed a number of type double as a parameter that represents a percentual portion of the maximum heart rate. The proportion is given as a number between zero and one. The class should have:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A constructor \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public Fitbyte(int age, int restingHeartRate)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A method \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public double TargetHeartRate(double percentageOfMaximum)\"), \" that calculates and returns the target heart rate.\")), mdx(\"p\", null, \"Use the formula 206.3 - (0.711 \", \"*\", \" age) to calculate the maximum heart rate.\\nUse the formula (maxHeartRate - restingHeartRate) \", \"*\", \" percentageOfMaximum + restingHeartRate to calculate the target heart rate.\"), mdx(\"p\", null, \"Use case:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  Fitbyte assistant = new Fitbyte(30, 60);\\n  double percentage = 0.5;\\n\\n  while (percentage < 1.0)\\n  {\\n    double target = assistant.TargetHeartRate(percentage);\\n    Console.WriteLine(\\\"Target \\\" + (percentage * 100) + \\\"% of maximum: \\\" + target);\\n    percentage = percentage + 0.1;\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Target 50% of maximum: 122.48500000000001\\nTarget 60% of maximum: 134.98200000000003\\nTarget 70% of maximum: 147.479\\nTarget 80% of maximum: 159.976\\nTarget 89.99999999999999% of maximum: 172.473\\nTarget 99.99999999999999% of maximum: 184.97000000000003\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#object","title":"Object"},{"url":"#class","title":"Class"}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"Object Oriented revision"}}},"pageContext":{"id":"47f28ba1-4c54-59be-8402-8a105028aa24"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}